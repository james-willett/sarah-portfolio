---
/**
 * FloatingIndex - Floating table of contents for project case study pages
 *
 * A sticky sidebar navigation that shows the main sections of a case study.
 * Highlights the currently visible section as the user scrolls.
 *
 * Design specs from Figma:
 * - Font: PP Radio Grotesk Regular, 16px, line-height 1.3
 * - Text color: #3F3F3F
 * - Gap between items: 16px
 * - Active state: bold weight
 *
 * Features:
 * - Sticky positioning (follows viewport while scrolling)
 * - Active section highlighting via Intersection Observer
 * - Smooth scroll to section on click
 * - Hidden on mobile (< 1024px)
 */

// Define the sections that will appear in the index
// These match the h2 headings in the MDX content
const sections = [
  { id: 'overview', label: 'Overview' },
  { id: 'problem', label: 'Problem' },
  { id: 'solution', label: 'Solution' },
  { id: 'outcome', label: 'Outcome' },
];
---

<nav
  class="floating-index hidden lg:flex flex-col gap-4"
  aria-label="Table of contents"
>
  {sections.map((section, index) => (
    <a
      href={`#${section.id}`}
      class="index-link text-base leading-[1.3] text-[#3F3F3F] hover:text-[#AAA] transition-colors"
      data-section={section.id}
    >
      {section.label}
    </a>
  ))}
</nav>

<style>
  /* Base styles for the floating index */
  .floating-index {
    font-family: 'PP Radio Grotesk', sans-serif;
    font-weight: 400;
  }

  /* Active link styling */
  .index-link.active {
    font-weight: 700;
  }

  /* Smooth transitions for active state */
  .index-link {
    transition: font-weight 0.15s ease, color 0.15s ease;
  }
</style>

<script>
  /**
   * FloatingIndex client-side functionality
   *
   * Uses Intersection Observer to detect which section is currently visible
   * and updates the active state of the navigation links accordingly.
   * Also handles smooth scrolling when clicking on index links.
   */

  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', () => {
    initFloatingIndex();
  });

  // Also re-init after Astro page transitions (View Transitions API)
  document.addEventListener('astro:page-load', () => {
    initFloatingIndex();
  });

  function initFloatingIndex() {
    const indexLinks = document.querySelectorAll('.index-link');
    const sections = document.querySelectorAll('article h2');

    if (indexLinks.length === 0 || sections.length === 0) return;

    // Add IDs to h2 elements if they don't have them
    // This creates anchor targets for the index links
    sections.forEach((section) => {
      if (!section.id) {
        // Convert heading text to kebab-case ID
        const text = section.textContent?.trim().toLowerCase().replace(/\s+/g, '-') || '';
        section.id = text;
      }
    });

    // Set up Intersection Observer to track visible sections
    // rootMargin creates a detection zone in the upper portion of the viewport
    const observerOptions = {
      root: null, // viewport
      rootMargin: '-20% 0px -60% 0px', // Trigger when section is in upper 40% of viewport
      threshold: 0,
    };

    let currentActiveId: string | null = null;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const id = entry.target.id;

          // Only update if the active section changed
          if (id !== currentActiveId) {
            currentActiveId = id;

            // Update active states on all links
            indexLinks.forEach((link) => {
              const linkSection = link.getAttribute('data-section');
              if (linkSection === id) {
                link.classList.add('active');
              } else {
                link.classList.remove('active');
              }
            });
          }
        }
      });
    }, observerOptions);

    // Observe all section headings
    sections.forEach((section) => {
      observer.observe(section);
    });

    // Handle click events for smooth scrolling
    indexLinks.forEach((link) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();

        const targetId = link.getAttribute('href')?.replace('#', '');
        if (!targetId) return;

        const targetElement = document.getElementById(targetId);
        if (!targetElement) return;

        // Smooth scroll to the target section
        // Offset by 100px to account for sticky header
        const offset = 100;
        const targetPosition = targetElement.getBoundingClientRect().top + window.scrollY - offset;

        window.scrollTo({
          top: targetPosition,
          behavior: 'smooth',
        });

        // Update URL hash without jumping
        history.pushState(null, '', `#${targetId}`);
      });
    });

    // Set initial active state based on current scroll position
    // Find which section is currently in view
    const viewportMiddle = window.innerHeight * 0.3;
    let closestSection: Element | null = null;
    let closestDistance = Infinity;

    sections.forEach((section) => {
      const rect = section.getBoundingClientRect();
      const distance = Math.abs(rect.top - viewportMiddle);

      if (rect.top <= viewportMiddle && distance < closestDistance) {
        closestDistance = distance;
        closestSection = section;
      }
    });

    // If no section is above the viewport middle, use the first section
    if (!closestSection && sections.length > 0) {
      closestSection = sections[0];
    }

    if (closestSection) {
      const id = closestSection.id;
      indexLinks.forEach((link) => {
        const linkSection = link.getAttribute('data-section');
        if (linkSection === id) {
          link.classList.add('active');
          currentActiveId = id;
        }
      });
    }
  }
</script>
